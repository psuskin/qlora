This is the description of the class "Path": Path(Filter::Access expression) With Path an access path for SetFormat can be put on the stack as a literal. Compared to the access expression in the string, this has the advantages that: The Eclipse IDE can provide syntax highlighting, parsing and auto-completion for expressions in Path() Within providers: The context for anonymous procedures is defined at the point where the path literal is created and not when SetFormat 197507 Path creates an object of the type CX_PATH_LITERAL on the stack. The object holds two internal representations of the access path, the original and a translated form. A CX_PATH_LITERAL can be used instead of the access expression in SetFormat, ClearFormat and SetSort and is not persistent and cannot be modified like regular strings. With the String command you get a string which can then be parsed again to the same CX_PATH_LITERAL by Execute. Example Example Before Dll version 197507 Path() was translated into a string at parse time and all anonymous procedures were compiled into the current module. This had the consequence that anonymous procedures in access expressions resulted in the fact that the access expression could not be used across module boundaries (a provider could not fill a list with formats) and on the other hand GetFormat only provided a complicated access expression that was only valid within a module and a ClassiX instance. This is the description of the functionality of the class "Path" regarding Execution context: Basically, the list in which the access expression was inserted via SetFormat determines the module context in which the expression is evaluated (exception: bound path literals). A call(proc) therefore always refers to the procedure proc from the module of the list widget, even if the path literal was created in another module (e.g. a provider). In this way, a provider can fill the list of another module with access expressions that refer to the list module. If the access expression is evaluated by Copy(STACK), the source of the CX_PATH_LITERAL object determines the evaluation context. If the Path object was returned from a list using GetFormatVector, the list is the evaluation context of this access path. If a path is evaluated by Copy(STACK) that was simply placed on the stack as a literal, it is executed in the context in which this literal was created. If such a bound access expression refers to the widget during evaluation (e.g. Path(CX_CLASS::call({Widget Copy(txt)})), then it is an error if this Path object is evaluated after the widget has been closed. Example (evaluation context of procedures) This behaviour may not be desirable in some cases. You can use call(provider::proc) to call the procedure of a specific provider in an access expression. If a format provider module wants to reference its own procedures, these must be preceded by the provider tag. This way you can control whether a procedure is called from the provider or the target module. This syntax is only allowed for providers. Procedures from regular modules cannot be called in this way. Example (Explicit Procedure Context). This is the description of the functionality of the class "Path" regarding Supplementary notes to the table: A.win1= Here the provider procedure that generated the access path was called in the context of A.win. This bound the module context for calling the anonymous procedure to the provider, but since the widget context does not change when a procedure is called (even a provider procedure call), the widget context of the access path was bound to the current context widget, which in this case was A.win. The entry A.win only appears for access paths originating from P, but not from B, because a procedure can only be called across module boundaries for provider modules. If you want to get an access path from module B, this must be done using SendMsg(.) and the receiver of this message then defines the widget context. A.win2 = Here a procedure from module A was called in the widget context A.win, which is why it was bound to the path object. - | B.win3 = Here the access paths were retrieved from module B via SendMsg(.). This means that the widget context bound here depends on whether the message was received from module B itself (-) or from a widget in module B (B.win). The slightly reddish highlighted cells may seem illogical at first glance, but follow directly from the rules of context binding and the handling of anonymous procedures from provider modules. The anonymous procedure receives a provider prefix and thus the module context within the anonymous procedures corresponds to the provider module P. SetFormat in A.list sets the evaluation context of the entire path (module = A / widget = A.list). This means that all expressions outside of anonymous procedures (that is, var(x) and call(proc)) are executed within this context. See also:.
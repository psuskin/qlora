This is the description of the class "The control file classix.ini": The initialisation file CLASSIX.INI describes in section Model classes MetaInfo how the objects of these classes are stored in the database MetaInfo all slots that can be generated Dictionary Properties of 'normal' data members Dictionary Scheme database MetaInfo Check-illegal pointer mode MetaInfo CLASSIX.INI is divided into two sections. The beginning of a section is marked with the keywords MetaInfo or Dictionary given in the table above. Syntax of the initialisation file The syntax of the file CLASSIX.INI is described completely in Backus-Naur-Notation. Terminal symbols are marked red: InitializationData ::= DictionarySection MetaInfoSection | MetaInfoSection DictionarySection | MetaInfoSection The syntax of the 'MetaInfo' section MetaInfoSection ::= MetaInfo | SchemaDB MetaInfo | CheckIllegalPointers SchemaDB MetaInfo | SchemaDB CheckIllegalPointers MetaInfo MetaInfo ::= ClassDescription FileDescription StorageDescription ClassDescription ::= ClassEntry | ClassDescription ClassEntry ClassEntry ::= Class(className, classID, fileName) | Class(className, classID, fileName, baseClassName) className ::= identifier baseClassName ::= identifier FileDescription ::= FileEntry | FileDescription FileEntry FileEntry ::= File(fileName, storageList) storageList ::= storageDescription | storageList, storageDescription fileName ::= name StorageDescription ::= StorageEntry | StorageDescription StorageEntry StorageEntry ::= Storage(storageName, physicalDataBase, Segment, EP(rootEPList), CSeg(collSegList), Garbage(rootEntryPoint, segmentName)) storageName ::= name segment ::= segmentName | segmentName(EXTERNAL) rootEPList ::= rootEntryPoint | rootEPList, rootEntryPoint rootEntryPoint ::= rootEntryPointName | rootEntryPointName(collectionType) rootEntryPointName ::= name collectionType ::= BAG | SET | LIST | ARRAY collSegList ::= segmentName | collSegList, segmentName segmentName ::= name name ::= identifier | string The syntax of the 'Dictionary' section INTEGER Finally, some of the elementary meta-variables used so far: identifier ::= letter | identifier alnum_char letter ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | _ digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 alnum_char ::= letter | digit integerNumber ::= digit | integerNumber digit There is no formal definition for 'string' and 'filename', whose shape can be assumed to be known. Section 'MetaInfo This section of the initialisation file tells the object manager which classes exist, how the database is logically divided and where within the database the objects of a class should be stored: The description where and how objects of a class are to be stored is summarised as a file. Different classes can use the same file information. A file refers to storages. The object manager keeps an index i and only the i-th storage is visible for all files, whereby the database is logically divided into independent areas - layers. When working in layer i, there is no access to the data in layer k. Layers divide the set of all stored objects into disjunctive subsets, i.e. an object can only belong to one layer. Storages define parameters that are directly related to the selected storage form. In the following storages for the database ObjectStore are described. ClassiX® can work with any number of physical databases - therefore this specification belongs to the storage. To understand the other parameters, a look at the internal structure of the ObjectStore database helps: The database is divided into segments. Consequently, it must be determined in which segment the objects are stored. To retrieve data in an ObjectStore database, it must be directly or indirectly connected to a root entry point. Collections connected to a root entry point are defined in the storage. These collections combine the objects of a class. The set of all objects of a class can be distributed to different collections. The resulting subsets are called domains in ClassiX®. An object may belong to several domains, i.e. the subsets are not necessarily disjunctive. An object may also be an element of the collection(s) of its base class(es). Just like objects, collections are located in a specific segment of the database. Since objects are often searched for within a collection, it is to be expected that the distribution of objects and collections to the segments will have an impact on the performance of an application. The object manager deletes an object only logically. For this reason, the storage includes information on where logically deleted objects are kept (segment, collection). As mentioned above, objects can be distributed to different physical databases. ObjectStore allows relations between objects in different databases. This feature must be activated explicitly by specifying EXTERNAL for the segment concerned. The type can be determined for each collection. Without explicit specification, a set is created. After the keyword Schema, the location of the ObjectStore schema database is specified. Especially when new classes are developed, illegal pointers can be written into the database due to program errors. ObjectStore can detect this - but at the expense of performance. With the keyword CheckIllegalPointer this mode is activated. Dictionary' section This section describes slots. A slot is identified by its name and an integer number. The data type must also be known. Even 'ordinary' data members can be described here. This is of interest for data fields of the types ENUMSHORT and ENUMCHAR, because they refer to a transformation table. InstantView® uses this table automatically if the value of such a data field has to be converted into a character string or vice versa. The window object Enumeration shows the identifiers from the table in a combo box.
This is the description of the class "Arithmetic": The following overviews show the mathematical operators and the operands with which a number can be linked. Some operations may surprise some people, because they do not necessarily follow strict mathematical rules. However, we believe that the agreements made in InstantView® are pragmatic when dealing with commercial calculations: Example for our rule: 10€ +10% = 11€ -> corresponds to 10€ + 10% of 10€ 30 pieces + 10% per 3 pieces = 60 pieces The main problem arises from the parallel use of numbers with and without units. The priority rules were developed to enable operations between different number object types. The following rules apply: The data type of the returned result is determined by the operand with the highest priority. There are the following exceptions to this: The operators (+=|-=|*=|/=)never change the type of the first operand. (CX_VALUE|CX_VALUE_PER)(*|/) (CX_VALUE|CX_VALUE_PER) always returns a CX_VALUE. Example: CX_VALUE_PER(10€ / 3m) * CX_VALUE(6m) = CX_VALUE(20€) Addition and multiplication are always commutative, so X + Y = Y + X and X * Y = Y * X. There are the following exceptions to this: CX_PERCENT (+|-|*|/|+=|-=|*=|/=) X is an error for all types X != CX_PERCENT. X (+|-|*|/|+=|-=|*=|/=) (STRING|ML_STRING) has a different semantics if the string is in front. CX_PERCENT(X) is considered as X/100 for mathematical operations. Example: 20 * (20% + 30%) = 20 * (20/100 + 30/100) = 20 * (50/100) = 10 There are the following exceptions to this: X(+|-|+=|-=) CX_PERCENT is defined (for X != CX_PERCENT) as a percentage markup/reduction: X(+|-|+=|-=) (X * CX_PERCENT). Example: 10 + 50% = 10 + (10 * 50%) = 10 + (10 * 50/100) = 10 + 5 = 15 CX_PERCENT (|=<|>) X compares the percentage points with the number X. The operation X (+=|-=|*=|/=) Y is only allowed if X is not a primitive type and X (+|-|*|/) Y gives a result which is convertible to type X without losing units. In the operation (CX_VALUE|CX_VALUE_PER) (+|-|+=|-=) X, with X ∉ {CX_VALUE, CX_VALUE_PER, CX_PERCENT} X is automatically supplemented by the unit of (CX_VALUE|CX_VALUE_PER). Example: 10€ + 3 = 10€ + 3€ = 13€ In the X(+|-|*|/|+=|-=|*=|/=) (STRING|ML_STRING) operation, the STRING is imported into the target type of X. Example: 20% + "30" = 20% + 30% = 50% String operations: (STRING|ML_STRING) + X converts X into a string and concatenates both. With an ML_STRING, X is exported in as many languages as the ML_STRING contains languages and concatenates language by language. Example: T("a", "b") + CX_VALUE(1 piece) = T("a1 pieces", "b1 pieces") ML_STRING * X converts X into a string and attaches it to each language. Example: T("a", "b") * CX_VALUE(1 piece) = T("a1 piece", "b1 piece") top priority CX_VALUE_PER CX_VALUE CX_FLOAT CX_FRACTION CX_NUMERIC CX_INTEGER CX_PERCENT lowest priority The introduction of priority between payment object types also optimises the transfer of old data into the ClassiX® system. As legacy data is often unitless, it had to be loaded into the previously created transient objects and provided with a unit, which meant an enormous effort. After the introduction of priority rules, all operations are "type commutative". For example, an integer number taken over from old data takes over its type when operating with a ClassiX® number object type. The commutative law applies to addition and multiplication. Subtraction and division, on the other hand, means that the operations are also possible with swapped number object types. CX_INTEGER(x) + CX_VALUE(y) = CX_VALUE(y) + CX_INTEGER(x) = CX_VALUE(x + y). This is the description of the functionality of the class "Arithmetic" regarding Units: Units are calculated in the way we know it from physics. Please note that the empty unit is also a unit. Thus there is the CX_VALUE object "0". ClassiX® knows a special unit, the question mark ? It is not to be understood as a unit, but as an auxiliary unit. It helps to solve the following calculation: Several values are to be added up, all having the same unit (e.g. €). The starting value is 0? If "0 + 1€" would be calculated, there would be an error, because the units do not match. "0? + 1€" on the other hand is allowed. ? is an auxiliary unit which says: Take the unit of the other operand for the result when adding and subtracting. The result is "0? + 1€ = 1€" and "1€ + 0? = 1€". In all other arithmetic operations and comparisons ? behaves like undimensioned, i.e. it is pretended as if the unit did not exist at all. At the end of a multiplication or division, the units are shortened, i.e. "kg/kg" becomes undimensioned, "piece * €/piece" becomes "€". ? always disappears: "1 * 2? = 2", "3? * 1? = 3", "2? / 2? = 1", "5 / 1? = 5". This is the description of the functionality of the class "Arithmetic" regarding Overflow: If the scope of a data type would be exceeded during an arithmetic operation, error 00-0060 ("Arithmetic error: overflow") is thrown. For example, a CX_INTEGER can contain values between - 231 and 231 - 1.
Dies ist die Beschreibung der Klasse "Path": Path(Filter::Zugriffsausdruck)Mit Path kann ein Zugriffspfad für SetFormat als Literal auf den Stack gebracht werden. Gegenüber des Zugriffsausdrucks im String hat dies die Vorteile, dass: Die Eclipse-IDE Syntax-Highlighting, Parsing und Auto-Vervollständigung für Ausdrucke in Path() anbieten kann Innerhalb von Providern: Der Kontext für anonyme Prozeduren wird an der Stelle festgelegt, an der das Path-Literal erzeugt wird und nicht beim Aufruf von SetFormat 197507Path legt dabei ein Objekt vom Typ CX_PATH_LITERAL auf den Stack. Das Objekt hält intern zwei Repräsentationen des Zugriffspfades, die originale und eine übersetzte Form. Ein CX_PATH_LITERAL kann anstelle des Zugriffsausdrucks in SetFormat, ClearFormat und SetSort verwendet werden und ist nicht persistierbar und lässt sich nicht wie reguläre Strings verändern. Über den Befehl String erhält man einen String, der dann per Execute wieder zu dem gleichen CX_PATH_LITERAL geparst werden kann.BeispielBeispiel Vor Dll-Version 197507 wurde Path() zur Parse-Zeit in einen String übersetzt und alle anonymen Prozeduren in das aktuelle Modul kompilliert. Das hatte zur Folge, dass anonyme Prozeduren in Zugriffsausdrücken dazu geführt haben, dass der Zugriffsausdruck nicht über Modulgrenzen hinweg verwendet werden konnte (ein Provider konnte eine Liste nicht mit Formaten befüllen) und zum anderen GetFormat nur einen kompillierten Zugriffsausdruck lieferte, der nur innerhalb eines Moduls und einer ClassiX-Instanz gültig war. Dies ist die Beschreibung der Funktionalität der Klasse "Path" bezüglich Ausführungskontext: Grundsätzlich bestimmt die Liste, in die der Zugriffsausdruck per SetFormat eingefügt wurde, den Modulkontext in dem der Ausdruck ausgewertet wird (Ausnahme: Gebundene Pfadliterale). Ein call(proc) bezieht sich also immer auf die Prozedur proc aus dem Modul des Listen-Widgets, auch wenn das Path-Literal in einem anderen Modul (z.b einem Provider) erzeugt wurde. Auf diese Weise kann ein Provider die Liste eines anderen Moduls mit Zugriffsausdrücken befüllen, die sich auf das Listen-Modul beziehen. Wird der Zugriffsausdruck per Copy(STACK) ausgewertet, dann bestimmt die Quelle des CX_PATH_LITERAL-Objekts den Auswertungskontext. Wurde das Path-Objekt über GetFormatVector aus einer Liste zurückgegeben, dann ist die Liste der Auswertungskontext dieses Zugriffspfads. Wird ein Pfad per Copy(STACK) ausgewertet, der einfach als Literal auf den Stack gelegt wurde, wird dieser in dem Kontext ausgeführt, in dem dieses Literal erzeugt wurde. Sollte sich ein solcher gebundener Zugriffsausdruck bei der Auswertung auf das Widget beziehen (Bsp: Path(CX_CLASS::call({Widget Copy(txt)})), dann ist es ein Fehler, wenn dieses Path-Objekt ausgewertet wird, nachdem das Widget geschlossen wurde. Beispiel (Auswertungskontext von Prozeduren) Dieses Verhalten kann in einigen Fällen nicht erwünscht sein. Über call(provider::proc) kann man in einem Zugriffsausdruck gezielt die Prozedur eines bestimmten Providers aufrufen. Sollte ein Format-Provider-Modul eigene Prozeduren referenzieren wollen, dann muss diesen das Providertag vorangestellt werden. So kann gezielt gesteuert werden, ob eine Prozedur aus dem Provider oder dem Zielmodul aufgerufen werden soll. Diese Syntax ist nur für Provider zulässig. Prozeduren aus regulären Modulen können auf diese Weise nicht aufgerufen werden. Beispiel (Expliziter Prozedurkontext). Dies ist die Beschreibung der Funktionalität der Klasse "Path" bezüglich Ergänzende Hinweise zur Tabelle: A.win1= Hier wurde im Kontext von A.win die Providerprozedur aufgerufen, die den Zugriffspfad erzeugt hat. Dadurch wurde zwar der Modulkontext für den Aufruf der anonymen Prozedur auf den Provider gebunden, da sich bei einem Prozeduraufruf (auch einem Providerprozeduraufruf) der Widget-Kontext aber nicht ändert, wurde der Widget-Kontext des Zugriffspfads insgesamt an das aktuelle Kontextwidget gebunden, was in dem Fall A.win war. Der Eintrag A.win taucht nur bei Zugriffspfaden auf, die von P stammen, nicht aber von B, weil nur bei Provider-Modulen eine Prozedur über Modulgrenzen hinweg aufgerufen werden kann. Will man einen Zugriffspfad von Modul B erhalten, dann muss dies per SendMsg(.) geschehen und der Empfänger dieser Message definiert dann den Widget-Kontext. A.win2 = Hier wurde eine Prozedur aus dem Modul A im Widget-Kontext A.win aufgerufen, weshalb dieser auch an das Pfad-Objekt gebunden wurde. - | B.win3 = Hier wurden die Zugriffspfade per SendMsg(.) aus dem Modul B geholt. Das heißt, dass der hier gebundene Widget-Kontext davon abhängt, ob die Message vom Modul B selbst empfangen wurde (-) oder von einem Widget im Modul B (B.win). Die leicht rötlich hinterlegten Zellen erscheinen auf den ersten Blick vielleicht unlogisch, folgen aber direkt aus den Regeln der Kontextbindung und der Behandlung von anonymen Prozeduren aus Provider-Modulen. Die anonyme Prozedur erhält einen Provider-Präfix und damit entspricht der Modulkontext innerhalb der anonymen Prozeduren dem Provider-Modul P. SetFormat in A.list setzt aber den Auswertungskontext des gesamten Pfads auf (Modul = A / Widget = A.list). Dadurch werden alle Ausdrücke außerhalb von anonymen Prozeduren (also var(x) und call(proc)) innerhalb dieses Kontexts ausgeführt. Siehe auch:.
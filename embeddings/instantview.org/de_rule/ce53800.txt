Dies ist die Beschreibung der Klasse "CX_SECURE_OBJECT_LOCATOR": 210849. Dies ist die Beschreibung der Funktionalität der Klasse "CX_SECURE_OBJECT_LOCATOR" bezüglich Beschreibung: Diese Klasse bietet mit GetLocation&GrabObject an ähnliches Interface an, wie CX_DB_UTILITY. Die Namensgleichheit ist durchaus gewollt, denn die Methoden tun das Gleiche mit dem Zusatz, dass GetLocation die ID zusätzlich per AES-128-CBC verschlüsselt und anschließend mit AES-128-CMAC signiert. GrabObject prüft die Signatur und entschlüsselt die ID ehe das Objekt/Collection geladen wird. Verschlüsselte Ids sollten überall da verwendet werden, so echte Datenbankadressen zu gefährlich sind (da durch Angreifer manipulierbar) und der Aufbau eigener Ids über die uniqueID oder über Maps zu umständlich oder langsam ist. Der CX_SECURE_OBJECT_LOCATOR hat einen 48-Byte langen binären Schlüssel (bestehend aus aesKey, iv, macKey), der den gesamten Zustand des Objekts repräsentiert und sicherstellt, dass eine generiete ID nur von dem Objekt mit dem korrekten Schlüssel geladen werden kann. Der aktuelle binäre Schlüssel kann in Form eines Base64-Strings (64 Zeichen lang) über die Methdoe GetKey ausgelesen werden und über SetKey durch einen neuen ersetzt werden. Der CX_SECURE_OBEJCT_LOCATOR ist immer mit einem zufälligen Schlüssel initialisiert, sodass die Objekte der Klasse ohne weitere Initialisierung direkt verwendet werden können. Dadurch, dass jedes CX_SECURE_OBJECT_LOCATOR-Objekt mit einem zufälligen Schlüssel initialisiert wird, sind zwei Locator-Objekte grundsätzlich inkompatibel zueinander und könenn die Ids des jeweils anderen Objekts nicht laden. Sollen beide Objekte die gleichen Ids generieren und laden, dann müssen sie mit dem gleichen Schlüssel initialisiert werden (SetKey). Die generierten IDs sollten nicht persistent abgelegt werden, da deren Format bei Bedarf geändert werden könnte. Dies ist die Beschreibung der Funktionalität der Klasse "CX_SECURE_OBJECT_LOCATOR" bezüglich Verschlüsselungsschema: aesKey = Schlüssel für die AES-Verschlüsselung iv = Initialisierungsvektor (Dieser ist im 48-Byte langen Schlüssel enthalten) macKey = Schlüssel für die MAC-Berechnung (Dieser ist im 48-Byte langen Schlüssel enthalten) Ein + bedeutet, dass die Inhalte konkateniert werden. BASE64( AES-128-CBC(id, iv, aesKey) + CMAC-AES-128(aesKey + iv + AES-128-CBC(id, iv, aesKey), macKey)(first 8 bytes) ) Der MAC-Code stellt eine Signatur dar, mit der in GetLocation vor der Entschlüsselung der ID geprüft wird, ob diese ID überhaupt von diesem CX_SECURE_OBJECT_LOCATOR generiert wurde. Ohne die Kenntnis des Schlüssels kann ein Angreifer also keine gültige Id generieren oder raten. Um das zu garantieren, wird der MAC zusätzlich zur verschlüsselten Nachricht auch über den AES-Schlüssel und den Initialisierungsvektor berechnet, sodass eine Änderung in einem der Parameter dazu führt, dass ein anderer MAC generiert wird. Der MAC wird auf den verschlüsselten Daten berechnet (Encrypt-Then-Mac), was als generell als Best-Practice angesehen wird, weil es Padding-Oracle-Angriffe unterbindet. Die Verwendung von AES verhindert zudem, dass ein Angreifer den Schlüssel errechnen kann, falls er (woher auch immer) die verschlüsselte Id im Klartext kennt, da es keine Known-Plaintext-Attacken gegen AES gibt. Vor der Verschlüsselung werden die Objekt-Ids platzsparend binär umkodiert, sodass eine typische ID trotz MAC und Base-64-Kodierung "nur" 32 Zeichen lang ist. Dies ist die Beschreibung der Funktionalität der Klasse "CX_SECURE_OBJECT_LOCATOR" bezüglich Code-Beispiel: * MA = Member-Access-Funktion, grau unterlegt = geerbte Funktion * I = Indizierbares Datenfeld, grau unterlegt = geerbtes Datenfeld.
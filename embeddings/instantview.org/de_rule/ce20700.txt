Dies ist die Beschreibung der Funktionalität der Klasse "CX_STATE_MONITOR - Statusmonitor" bezüglich Beschreibung: Diese Klasse verwaltet einen Statusmonitor. Statusmonitore sind spezielle Monitor-Objekte, die über das Datenfeld transitions mit anderen Statusmonitoren zu einem Petri-Netz verknüpft sind und auf diese Weise Geschäftsprozesse abbilden. Der eigentliche Geschäftsprozess (CX_WORK_FLOW-Objekt) hält die einzelnen Zustände lediglich in seiner monitors-Collection und ist in den CX_STATE_MONITOR-Objekten als owner hinterlegt. CX_TRANSACTION-Objekte können per ConnectStateMonitor erstmalig mit dem Start-Zustand eines solchen Petri-Netzes verknüpft werden. Dabei wird die Transaktion auch direkt in diesen Start-Monitor gebucht (Verknüpfung über CX_TRANSACTION։։monitors und CX_STATE_MONITOR։։transactions). Per TriggeredStateMonitor werden die Transaktionen dann durch das Petri-Netz geschaltet (wobei die Transaktion eine Marke im Petri-Netz repräsentiert). Hierzu werden die Transitionsbedingungen vom Startzustand ausgehend (wichtig) ausgewertet, bis der Zustand gefunden wird, aus dem keine Transitionsbedingung mehr erfüllt ist. Die Transaktion wird dann mit diesem neuen Zustand verknüpft und für den früheren Zustand wir die Message STATE_OUT und für den neuen Zustand STATE_IN gefeuert. Die Auswertung vom Startzustand aus führt dazu, dass jeder Zustand nur vom Start-Zustand (über beliebige Zwischenzustände) erreichbar sein muss. Im Gegensatz zu einem regulären Petri-Netz muss für einen Zustandsübergang von A->B keine Transition A->B definiert sein, denn solange A und B vom Startzustand erreichbar sind, kann TriggeredStateMonitor einen solchen Übergang durchführen. Mit RemoveStateMonitor kann die Verbindung wieder aufgehoben werden. Die Operation ist invers zu ConnectStateMonitor. Nachdem eine Transaktion einen Zustandswechsel (TriggeredStateMonitor) vollzogen hat, wird an den Zustandsmonitor des Quellzustands die Message STATE_OUT direkt gesendet (siehe: ObjectCode) und anschließend an den Zustandsmonitor des Zielzustands die Message STATE_IN gefeuert. Wenn die Message gefeuert wird, liegt die Transaktion als einzgies Objekte auf dem Stack. Bei ConnectStateMonitor wird STATE_IN am Start-Zustand gefeuert. Bei RemoveStateMonitor wird STATE_OUT am aktuellen Zustand gefeuert. Dies ist die Beschreibung der Funktionalität der Klasse "CX_STATE_MONITOR - Statusmonitor" bezüglich Code-Beispiel: * MA = Member-Access-Funktion, grau unterlegt = geerbte Funktion * I = Indizierbares Datenfeld, grau unterlegt = geerbtes Datenfeld.
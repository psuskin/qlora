Dies ist die Beschreibung der Funktionalität der Klasse "CX_GENERAL_TERMS" bezüglich Beschreibung: Geschäftsbedingungen sind begleitende Angaben/Daten/Informationen. Die gebräuchlichsten sind z.B. Zahlungs- oder Lieferbedingungen, aber auch Rechnungsadresse, Mahnungsempfänger, Verpackungsanweisungen oder -kosten fallen hierunter. Auch Fertigungshinweise, Arbeitsanweisungen oder Durchführungsvorschriften interner Art können als (Rand-)bedingungen angesehen werden. Die Haupteigenschaften derartiger Bedingungen oder Vereinbarungen sind: 1. Sie können auf unterschiedlichen Ebenen definiert sein. Vereinbarungen können z.B. auf Ebene eines einzelnen Auftrages, generell für einen einzelnen Kunden oder allgemein für alle Kunden gelten. --> CX_BUSINESS_OBJECT hält Datenfeld CX_GENERAL_TERMS* generalTerms Damit möglich, für versch. Geschäftsobjekte verschiedene oder gleiche Bedingungen zuzuordnen. Natürlich trotzdem möglich, jedem Geschäftsobjekt direkt, d.h. ohne ein CX_GENERAL_TERMS Objekt Daten hinzuzufügen. 2. Eine allgemeine Vereinbarung kann für einen speziellen Fall verändert werden. So wird z.B. bei einem speziellen Auftrag eine andere Lieferbedingung vereinbart, als sie sonst üblicherweise generell für alle Aufträge gilt. Dennoch sind alle anderen Bedingungen (Zahlungsbedingung, Versandart, usw.) auch für diesen speziellen Auftrag unverändert gültig. --> Sukzessive Suche nach einer Information notwendig. CX_CONDITION versucht für alle eigenen dynamischen Datenfelder (slots) die gesuchte Information zu finden - auch unter Weitergabe an diese Objekte -, CX_GENERAL_TERMS durchsucht auch noch die Liste conditions. CX_CONDITION/CX_GENERAL_TERMS überladen dazu GetDataField, PlugSlot, wohingegen CX_BUSINESS_OBJECT dieses nur aufgrund der Funktion Condition() macht. Mit CX_CONDITION/CX_GENERAL_TERMS kann man jede Funktion/jedes Datenfeld aufrufen, wenn nichts gefunden, kommt invalid zurück. (Aus IV heraus Unterscheidung zwischen 0 und Invalid notwendig !) Ein Datenfeld/Zugriffsausdruck/Objekt kann auf drei verschiedene Weisen als verarbeitbare Information definiert sein: 1. Der Name definiert direkt die Information (z.B. itemPrice) 2. Angaben im Objekt definieren die Information (z.B. classID == IDX_PAYMENT_CONDITION && enum = 3) 3. Ein Wrapper h„lt die Information mittels eines Datenfeldes (z.B. addressTypeEnum = 2 -> deliveryAddress; auch Bitmuster möglich) Holen der Information (Funktion CX_BUSINESS_OBJECT::Condition() ?) zu 1. GetData allerdings sollte weiter gesucht werden im PlugSpace !! zu 2. Query über Formel und über Suche im PlugSpace zu 3. kann wie 2. behandelt werden. Beispiele: Eine Lieferadresse wird dadurch spezifiziert, dass sie entweder direkt an einem POINTER slot "deliveryAddress" hängt, oder über eine DESCRIPTIVE oder OVERWRITING Reference mit (addressTypeEnum & DELIVERY_ADDRESS) definiert wird. Eine Zahlungsanweisung wird dadurch spezifiziert, dass sie über ein POINTER slot "payment" definiert ist, oder über eine DESCRIPTIVE oder OVERWRITING Reference definiert wird, in der der slot "paymentTypeEnum" vorkommt, oder das referenzierte Objekt vom Typ CX_PAYMENT_CONDITION ist. CX_CLASS* CX_BUSINESS_OBJECT::Condition(CX_FORMULA* _formula) CX_CLASS* CX_BUSINESS_OBJECT::Condition(short _classID) CX_CLASS* CX_BUSINESS_OBJECT::Condition(char* _name) ConditionByFormula(ByQuery) ConditionByType ConditionByName Beispiele für von CX_CONDITION als Pseudoklassen abgeleitete Klassen: Zahlungsbedingung CX_PAYMENT_CONDITION Preisstellung CX_PRICING_CONDITION Verpackung CX_PACKING_CONDITION Versandart CX_SHIPPING_CONDITION Gewährleistung CX_WARRANTY_CONDITION Lieferzeit CX_DELIVERY_CONDITION Bindefrist CX_BINDING_CONDITION. Dies ist die Beschreibung der Funktionalität der Klasse "CX_GENERAL_TERMS" bezüglich Code-Beispiel: * MA = Member-Access-Funktion, grau unterlegt = geerbte Funktion * I = Indizierbares Datenfeld, grau unterlegt = geerbtes Datenfeld.
Dies ist die Beschreibung der Klasse "Die Steuerungsdatei classix.ini": Das Initialisierungs-File CLASSIX.INI beschreibt in Sektion Modellklassen MetaInfo wie die Objekte dieser Klassen in der Datenbank gespeichert werden MetaInfo alle generierbaren Slots Dictionary Eigenschaften 'normaler' Datenmember Dictionary Schema-Datenbank MetaInfo Check-illegal-Pointer-Modus MetaInfo CLASSIX.INI ist in zwei Sektionen unterteilt. Der Beginn einer Sektion wird mit den in obiger Tabelle angegeben Schlüsselwörtern MetaInfo bzw. Dictionary gekennzeichnet. Syntax des Initialisierungs-FilesDie Syntax des Files CLASSIX.INI wird vollständig in Backus-Naur-Notation beschrieben, wobei Terminalsymbole rot gekennzeichnet sind:InitializationData ::= DictionarySection MetaInfoSection | MetaInfoSection DictionarySection | MetaInfoSection Die Syntax der Sektion 'MetaInfo'MetaInfoSection ::= MetaInfo | SchemaDB MetaInfo | CheckIllegalPointers SchemaDB MetaInfo | SchemaDB CheckIllegalPointers MetaInfo MetaInfo ::= ClassDescription FileDescription StorageDescription ClassDescription ::= ClassEntry | ClassDescription ClassEntryClassEntry ::= Class(className, classID, fileName) | Class(className, classID, fileName, baseClassName)className ::= identifierbaseClassName ::= identifier FileDescription ::= FileEntry | FileDescription FileEntryFileEntry ::= File(fileName, storageList)storageList ::= storageDescription | storageList, storageDescriptionfileName ::= name StorageDescription ::= StorageEntry | StorageDescription StorageEntryStorageEntry ::= Storage(storageName, physicalDataBase, Segment, EP(rootEPList), CSeg(collSegList), Garbage(rootEntryPoint, segmentName))storageName ::= nameSegment ::= segmentName | segmentName(EXTERN)rootEPList ::= rootEntryPoint | rootEPList, rootEntryPointrootEntryPoint ::= rootEntryPointName | rootEntryPointName(collectionType)rootEntryPointName ::= namecollectionType ::= BAG | SET | LIST | ARRAYcollSegList ::= segmentName | collSegList, segmentNamesegmentName ::= namename ::= identifier | string Die Syntax der Sektion 'Dictionary'INTEGER Zum Schluss noch einige der bisher benutzten elementaren Metavariablen: identifier ::= letter | identifier alnum_charletter ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | _digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9alnum_char ::= letter | digitintegerNumber ::= digit | integerNumber digitEs fehlt die formale Definition für 'Zeichenkette' und 'Filename', deren Gestalt als bekannt vorausgesetzt werden darf. Sektion 'MetaInfo'Dieser Abschnitt des Initialisierungs-Files teilt dem Objektmanager mit, welche Klassen es gibt, wie die Datenbank logisch aufgeteilt wird und an welcher Stelle innerhalb der Datenbank die Objekte einer Klasse gespeichert werden sollen:Die Beschreibung, wo und wie Objekte einer Klasse zu speichern sind, wird als File zusammengefasst. Verschiedene Klassen können die gleiche File-Information benutzen. Ein File verweist auf Storages. Der Objektmanager führt einen Index i und lässt für alle Files jeweils nur den i-ten Storage sichtbar werden, wodurch die Datenbank logisch in voneinander unabhängige Bereiche - Layer - aufgeteilt wird. Wenn man in Layer i arbeitet, besteht kein Zugriff auf die Daten in Layer k. Layer unterteilen die Menge aller gespeicherten Objekte in disjunkte Teilmengen, d.h. ein Objekt kann nur einem Layer angehören.Storages definieren Parameter, die direkt mit der gewählten Speicherungsform zusammenhängen. Im folgenden werden Storages für die Datenbank ObjectStore beschrieben. ClassiX® kann mit beliebig vielen physischen Datenbanken arbeiten - daher gehört diese Angabe zum Storage. Für das Verständnis der anderen Parameter hilft ein Blick auf die innere Struktur der ObjectStore-Datenbank:Die Datenbank ist in Segmente unterteilt. Folglich muss festgelegt werden, in welchem Segment die Objekte gespeichert werden. Um Daten in einer ObjectStore-Datenbank wiederzufinden, müssen sie direkt oder indirekt mit einem Root-Entry-Point verbunden sein. Im Storage werden mit einem Root-Entry-Point verbundene Collections definiert. Diese Collections fassen die Objekte einer Klasse zusammen. Die Menge aller Objekte einer Klasse kann auf verschiedene Collections verteilt sein. Die damit entstehenden Teilmengen heißen bei ClassiX® Domains. Ein Objekt darf mehreren Domains angehören, d.h. die Teilmengen sind nicht notwendigerweise disjunkt.Ein Objekt darf auch Element der Collection(s) seiner Basisklasse(n) sein. Ebenso wie Objekte befinden sich auch die Collections in einem bestimmten Segment der Datenbank. Da innerhalb einer Collection häufig nach Objekten gesucht wird, ist damit zu rechnen, dass die Verteilung der Objekte und Collections auf die Segmente die Performance einer Anwendung mitbestimmt.Der Objektmanager löscht ein Objekt nur logisch. Deshalb gehört zum Storage die Angabe, wo logisch gelöschte Objekte aufbewahrt werden (Segment, Collection).Wie oben erwähnt, können Objekte auf verschiedene physische Datenbanken verteilt werden. ObjectStore erlaubt Relationen zwischen Objekten in unterschiedlichen Datenbanken. Dieses Feature muss jedoch explizit aktiviert werden, indem für das betroffene Segment EXTERN angegeben wird.Für jede Collection kann der Typ bestimmt werden. Ohne explizite Angabe wird eine Set erzeugt.Nach dem Schlüsselwort Schema wird angegeben, wo sich die ObjectStore-Schema-Datenbank befindet.Besonders wenn neue Klassen entwickelt werden, können durch Programmfehler illegale Pointer in die Datenbank geschrieben werden. ObjectStore kann dies feststellen - jedoch auf Kosten der Performance. Mit dem Schlüsselwort CheckIllegalPointer wird dieser Modus aktiviert. Sektion 'Dictionary'In diesem Abschnitt werden Slots beschrieben. Ein Slot wird durch seinen Namen und eine ganze Zahl identifiziert. Außerdem muss der Datentyp bekannt sein.Auch 'gewöhnliche' Datenmember können hier beschrieben werden. Dies ist für Datenfelder der Typen ENUMSHORT und ENUMCHAR von Interesse, da hier auf eine Transformationstabelle verwiesen wird. InstantView® benutzt diese Tabelle automatisch, wenn der Wert eines solchen Datenfeldes in eine Zeichenkette konvertiert werden muss oder umgekehrt. Das Windowobjekt Enumeration zeigt die Bezeichner aus der Tabelle in einer Combobox.
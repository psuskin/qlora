Dies ist die Beschreibung der Funktionalität der Klasse "CX_STOCK - Lager" bezüglich Beschreibung: Diese Klasse verwaltet ein Lager. Ein Objekt vom Typ CX_STOCK beschreibt als CX_CLEARING_OBJECT einen Lagerungsort. Gehören verschiedene Lagerungsorte zu einem bestimmten Bereich (Werk, Abteilung, .), dann kann dieses über CX_DOMAIN Objekte modelliert werden. Jeder Lager(ungs)ort hat mindestens einen Lagerplatz, der als CX_ACCOUNT Objekt modelliert wird. Diesem Konto kann die Mengeneinheit, die Kapazität, ein Sperrvermerk, das maximale Gewicht, . als dyn. Datenfelder implementiert werden. Hat ein Lagerort mehrere SELBSTVERWALTETE Lagerplätze (chaotisches Lager), dann werden entspr. mehrere CX_ACCOUNT Objekte generiert, die genau diese Kapazitäten kontrollieren und verteilen können. Über main/subMonitors sind dem/den CX_ACCOUNT (Lagerplatz) Objekt(en) des Lagerortes die CX_ACCOUNT Objekte der einzulagernden Waren zugeordnet. Eigenschaften wie: - Hochregallager, WE, WA, Kommissionerlager, . - Kommissioniertechnik - Behandlung von Inventurdifferenzen - Ein- und Auslagerungsstrategien (manueller Platz, Blocklager, .) - Quittierungspflichten - Nullkontrolle - Gefahrstoffe, etc, etc, werden ebenfalls über dyn.Datenfelder und entspr. Berücksichtigung in den Skripts modelliert. Die dyn.Datenfelder werden in die dafür sinnvollsten Objekte gestellt. FIFO, LIFO Eigenschaften müssen von den CX_ACCOUNT Objekten unterstützt werden, ebenso Angaben ob Schnell- oder Langsamdreher vorliegen. Feste Attribute: stockEnum: Eigenlager (0), Konsignationslager (1), Zollager (2), . (Bit-Muster) location : POINTER vom Typ CX_ACCESS für Angabe, wo sich das Lager befindet OFFEN: Kapazität des Lagerplatzes (CX_ACCOUNT) LIFO, FIFO (CX_ACCOUNT) Schnell-, Langsamdreher (CX_ACCOUNT). Dies ist die Beschreibung der Funktionalität der Klasse "CX_STOCK - Lager" bezüglich Code-Beispiel: * MA = Member-Access-Funktion, grau unterlegt = geerbte Funktion * I = Indizierbares Datenfeld, grau unterlegt = geerbtes Datenfeld.
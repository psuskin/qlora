Dies ist die Beschreibung der Funktionalität der Klasse "CX_TIMED_TRIGGER - Signal-Klasse" bezüglich Beschreibung: Mit einem Objekt dieser Klasse können Aktionen verwaltet werden, die nicht sofort, sondern zu einem oder mehreren bestimmten Zeitpunkten ausgelöst werden sollen. Die Aktion besteht aus (jeweils optionalen) zwei Schritten und wird zum mit SetActionTerm gesetzten Zeitpunkt ausgelöst: Mit SetCycles kann die maximale Anzahl der gesendeten Signale zusätzlich fest vorgegeben werden. Falls sowohl Start-Message, als auch End-Message definiert sind, dann wird die Start-Message immer vor der End-Message gesendet. Die gesendeten Messages werden immer mit den gleichen Parametern auf dem Stack aufgerufen: Anwendungs-Beispiele:. Dies ist die Beschreibung der Funktionalität der Klasse "CX_TIMED_TRIGGER - Signal-Klasse" bezüglich Code-Beispiel: Der TimeTrigger läuft in einem eigenen Thread. Dies bedeutet, dass er Nachrichten auch sendet, wenn der Hauptthread beschäftigt ist und die Nachrichten gar nicht bearbeiten kann. Die Nachrichten werden dann in eine Warteschlange gestellt, bis der Hauptthread wieder frei ist und werden dann empfangen. Hierdurch kann die gleiche Nachricht des TimeTrigger binnen kürzester Zeit relativ häufig empfangen werden. Durch folgenden Beispielcode wird nur die letzte Nachricht der aufgesammelten beachtet und die anderen ignoriert. // create timed trigger CreateTransObject(CX_TIMED_TRIGGER) -> timedTrigger (TIME_TRIGGER_MESSAGE) timedTrigger Call(SetMsg) CreateTransObject(CX_PERIODIC_SPAN_TIME, KEEP) -> tmpTime // Set frequency in seconds 5s tmpTime Put(frequency) // fire once every 5 seconds 3 tmpTime Put(validEnum) tmpTime timedTrigger Call(SetActionTerm) // Activate trigger timedTrigger Call(Activate) // Handling duplicate messages in the trigger message TIME_TRIGGER_MESSAGE: Integer -> tmpIndex DropAll // only execute the last message if there are more than one in the pipe timedTrigger Call(TimesTriggered) tmpIndex > if return.
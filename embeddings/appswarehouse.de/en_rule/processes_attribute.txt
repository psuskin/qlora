This is the description of the module "processes_attribute" with the name "Attributes - Processes": 2.1 Preset attribute A preset attribute allows a dynamic data field to be given a descriptive name, further explanatory data or a default setting. Example: A carpet seller with a ClassiX® software wants to describe his carpets by different characteristics. For example, all carpets should be described by their price. So he adds a characteristic to all master data, in which he can then specify the price. If individual carpets are to be described by their colour (no free input, only colours from a colour table should be available), he can do this by means of an attribute, which for example describes a data field of type 'String'. This attribute is then provided with a table with the different colours. Attention: Attribute values are only supported in the formulas up to a maximum of 100 characters! 2.2 Formula attributes As the name suggests, formula attributes are used to fill a data field with a formula, or with the value that the formula calculates. Constants can be entered directly into the formula while the variable values are slot attributes. Example: The carpet seller now wants to describe his carpets also by size, whereby the carpets have the characteristic that all carpets have the same width (4m) and differ only in length. Here the carpet seller benefits from the formula attributes. So he creates an attribute with the formula '4m * length'. The length is again a preset attribute, whereby the value or the result of the formula attribute changes automatically when the value is changed. 2.3 Conditional attributes Conditional attributes can contain a table that describes an "if - then" relationship. Example: The carpets of the carpet seller are to have their own price per colour. We now create a conditional attribute and fill the table with the data we need for the price calculation. (e.g.: red -> 10 € ; blue -> 20 € ; yellow -> 30€ ) In addition, we set our just created attribute in dependence of the attribute for the colour.(see example Preset attribute) If the attribute for the colour is changed, the corresponding value of the condition table is now automatically returned. This is the description of the functionality of the module "processes_attribute" with the name "Attributes - Processes" regarding 1. why attributes?: Attributes are of central importance in ClassiX®, as they allow to describe an object (object, person object or similar) in all its characteristics without having to make changes to the source code. Example: The aim is to describe a sales item by its colour. This is the description of the functionality of the module "processes_attribute" with the name "Attributes - Processes" regarding 6. gradual and conditional expression of attributes: Attribute nodes allow the gradual and conditional expression of attributes. This is particularly useful in product configuration (the specification of variant parts), but can also be useful when entering any form (document) or master data. This is the description of the functionality of the module "processes_attribute" with the name "Attributes - Processes" regarding Application example for the gradual development: An application example for the gradual development of attributes is the division of a complex table of values of an attribute. Let us assume there is an attribute "MATERIAL". Behind this attribute there is a very large selection of different materials (various types of steel, aluminium and plastic as well as numerous alloys). This table can become very long, so it could take longer to select the right material. As a solution to this problem, the attribute "MATERIAL" can be created several times and the result table can be restricted in each case. So mine could create an attribute for steel, aluminium etc. and offer only the corresponding selection options as a result table. In addition you would have to create a new attribute "MATERIAL_ART" with the selection table: steel, aluminium, plastic and alloys. Behind this attribute, an attribute node is stored, which refers to the corresponding attribute "MATERIAL" depending on the set value. For example, in the sales item the attribute "MATERIAL_ART" is then inserted instead of the complex table "MATERIAL". In the order, you then first select "MATERIAL_ART". The corresponding attribute "MATERIAL" is then automatically added and in the second step this value can then be set. This is the description of the functionality of the module "processes_attribute" with the name "Attributes - Processes" regarding Application example for the conditional gradual characteristic: The conditional characteristic behaves similarly to the application example mentioned above, but is a little more complex. In the first example, the expression of one attribute led to other attributes with the same name with filtered result tables. However, an extensive product configuration can also be carried out via the attribute nodes. Let us imagine the configuration of a car. A car can be defined by many parameters. However, these parameters can be strongly interdependent. For example, after selecting 2- or 4-door, the question of rear electric windows may be obsolete. The same applies if one of the parameters is selected as the series and various extras are then already included. This type of multi-level conditional configuration is also possible via the attribute nodes. This is the description of the functionality of the module "processes_attribute" with the name "Attributes - Processes" regarding 7. editing of attributes in master and transaction data: The group for editing attributes on master data and transaction data is usually as follows. Global attributes are represented by the globe, local attributes are marked with the box. The values can be maintained by double-clicking on one of the attributes. Behind the purple lines there are visible attributes which have been inserted in a structured way. This means that various attributes have been combined into an attribute node (see Structuring of Attributes). By double-clicking on the purple line, the node is expanded and the attributes of this node are displayed. Another double-click collapses the node again. The button "Edit" leads to a selected . . global attribute to edit the attribute value in the list. . local attribute for editing the attribute in the edit mask . purple attribute node for editing the node designation in the list The list of attributes can be extended by clicking the "Insert" button. The normal case is that a root attribute is selected and inserted. Here there are the options "At end", "Before selected position" and "Behind selected position". In addition, a local attribute can also be created. Here the type of the attribute ("Presettable", "Calculated", "Conditional") must be determined via the menu. Via the menu "Insert new structural level" an attribute node can be created manually. Attributes can then be moved up and down in this node using the arrows. The arrow keys take over the function to determine the order of the attributes. You can also move an attribute into an attribute node or retrieve it again. Before attributes are moved to a level from within it, the user is asked if he really wants to perform this action. This is the description of the functionality of the module "processes_attribute" with the name "Attributes - Processes" regarding 8. use of comparison operators: Even before creating a new attribute with an attached table, it is important to know how to work with it later. You must also be aware that the attributes can have different types internally, e.g. STRING, ENUMCHAR, etc. In the case of characteristics created as type STRING or with a data field of type STRING, the value (text) entered by the user is retained internally and is therefore also used for comparisons. If, however, you create a characteristic with the type ENUMCHAR, for example, the internal structure of the attached table is different. There is no longer the value directly (e.g. text in the case of the type STRING), but in the internal table there is a numbering given by the feeder and for each of the entries the value to be shown externally, e.g. 1 -> apples, 2 -> pears and 3 -> bananas. For comparison operations, the internal value is always used in all cases of e.g. ENUMCHAR, because you cannot compare apples with pears over "bigger" or "smaller", so to speak. But of course you can test for "equal" without any problems, but you have to be very careful with "not equal" comparisons. This is especially true in cases where one has created, for example, the following table: 1 -> "100", 2 -> "200" and 3 -> "150". There you cannot simply make the comparison "less than or equal to 200", because the "200" is first converted into the internal value 2, and with the internal values only 1 and 2 are "less than or equal to 2", so that the entry 3 -> "150" is not output. This is the description of the functionality of the module "processes_attribute" with the name "Attributes - Processes" regarding 9. attributes with control functions: The following attributes are interpreted internally in the ClassiX system and control certain functionalities in the system.
This is the description of the module "query" with the name "Database query": This module is used to search for information. On the one hand, this can be done using the search terms categorised by object type, and on the other hand using general and more technical query functions. This is the description of the functionality of the module "query" with the name "Database query" regarding Advanced search: The "Advanced Search" window is always accessed via another module. Usually these are list windows, in which there is a field Search terms. If the simple search using the search terms is not sufficient here, this mask can be called up here as an alternative. The results of the search are always sent back to the calling module, which then takes over the display. This is the description of the functionality of the module "query" with the name "Database query" regarding Data preparation and filtering: In the widget for data preparation and filtering, various criteria are specified and linked with each other. During execution, these are arranged in such a way that execution is as fast as possible while the meaning of the configured logical expression remains the same. As soon as it can be decided for an object whether it belongs to the result set for sure or not, no further criteria are evaluated for this object. This is the description of the functionality of the module "query" with the name "Database query" regarding Criteria: At the beginning the widget is still empty and criteria can be added using the green plus. The individual criteria can be removed using the red X on the right-hand side. The order of the criteria can be changed with the arrows on the left side. The individual criteria can be connected by the links AND and OR to form expressions of truth. In addition, the opening and closing brackets can be used for grouping. Unclosed brackets are automatically closed at the end. This is the description of the functionality of the module "query" with the name "Database query" regarding Categories: Each criterion can be from one of five categories: Query, Attribute, Formula, Callback or InstantView. A criterion of type Query defines a condition for a data field of an object so that it belongs to the result set. The first of the fields defines the access expression to be tested. Instead of the access expression, the name of a column can also be entered. Using the button with the three dots next to the field, either an access expression can be selected via the access expression configurator or one of the defined columns. In the middle the comparison operator is selected and then the value to be compared with is entered on the right. If a method is selected and it cannot be used in a query expression, the criterion is automatically converted into one of the type callback during execution. A criterion of type attribute defines an attribute with a comparison operator and a comparison value. For each object it is checked whether it has the corresponding attribute and whether the value of the attribute matches the relational operator and comparison value. With a criterion of type formula, a formula is defined which is then evaluated for each object. If the formula returns TRUE (or a value that evaluates to TRUE), the object belongs to the result set, otherwise it does not. A criterion of type Callback specifies InstantView速 source code that is called for each object. The object is at the top of the stack. The source code should return a value at the end that is TRUE if the object belongs to the result set, otherwise a value that evaluates to FALSE. A criterion of the InstantView type is different from the other criteria in that it is not called for each object individually. Instead, when the specified InstantView速 source code is executed, a collection with the previously selected objects is on the stack and at the end a collection with objects on the stack is expected again. The use of this criteria type offers full flexibility in editing options. Naturally, a criterion of this type cannot be moved to another point of processing, so a criterion of the InstantView type interrupts the optimisation. Criteria before and after this criterion are optimised on their own, but it is ensured that all criteria before this criterion are executed before and all criteria after this criterion are executed afterwards. For the same reason no brackets can be defined for this criterion and all previously opened brackets are automatically closed. This is the description of the functionality of the module "query" with the name "Database query" regarding Parameter: Parameters can be used to determine the criteria dynamically during execution. This is useful, for example, to start reports for the current month. Parameters can be used for criteria of type Query, Callback or InstantView, but not for formulas. The easiest way to use parameters is to use the button with the three dots to the right of the corresponding fields. In the selection you have the possibility to define new parameters or edit existing parameters. The definition of a parameter is replaced by its value during execution. If parameters are to be defined manually, this can be done using the following syntax: ${Name := Initialisation}$ Name stands for the name and is optional (in this case := is also omitted). The name can be given either as a simple string or multilingual as T("first language", "second language"). Initialisation contains InstantView速 source text that is evaluated during execution and calculates the current value of the parameter. This source text can contain the following constants: If the check box Query parameters is selected for a criterion, a window with the parameters of this criterion and the calculated values is displayed during execution. The names of the parameters are used for this. The values can still be changed in the window. Since valid InstantView速 syntax is expected during initialisation, pure text specifications (e.g. as pre-entered values in the parameter query) must be stored in string notation with double inverted commas. Otherwise the text will be wrongly interpreted as a statement and not recognised: ${name := "given string"}$ In addition to the initialisation via source code, there is also the possibility to use selection windows for the values of the parameters. The syntax for this is then ${Name := //START_MSG;END_MSG}$ Name is again the name of the parameter. START_MSG defines the message to be sent to open the selection window and END_MSG defines the message to return the result from the selection window.
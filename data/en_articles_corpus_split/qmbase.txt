qmbase: This app (hereinafter also referred to as QM app ) is part of the CyberEnterprise quality management. Using Excel files with a specific structure, manual entries by users can be simulated and the results of these entries can be checked automatically. (In the classic evaluation system test framework Excel files are available in the directory .\Projects\TestFrameworks\Data\). The format of these Excel files is as follows: #Flags #Comment #ExecuteString #CommandString #Variable Test access expressions Flags (capitalisation also permitted) Flags Description rem; comments a line from break; leads to the termination of the processing sleep; following lines are not executed until the next "wakeup;" flag. This is an easy way to comment out lines in a test framework. wakeup; the following lines are executed again. load; other test frameworks can be included, for example to create parts However, it is not intended to link several evaluations to each other, as no evaluation files are written and no errors are logged when the flag "load" is set. goto:line number:condition goto statement: The syntax looks like this: goto:19:var 3 < The first part "goto" defines the GoTo statement. Then follows the line number to which the jump is to be made and the last part (e.g. var 3 <, i.e. the value of a previously defined variable var should be less than 3) defines the condition under which the jump label is approached. Only if this condition returns TRUE the GOTO instruction is executed to avoid endless loops. idle(waiting time); The processing of the test framework is paused by the waiting time in ms. The system is idle during this waiting time. This allows the behaviour of the system when waiting for user input to be simulated. Comment: Here you can enter descriptive information about the line. ExecuteString (called column 1 below): The string specified here is placed on the stack as a string. The specifications made here are only used for the purpose of being able to execute the TEST_. or EXEC_. Message in a target module to be executed by Execute. If any TEST_. or EXEC_. is missing message is missing, the entries in this column do not lead to a result. (Note: All AppsWarehouse Apps "understand" a TEST_. or EXEC_ message, which only allows the command "Execute" to be executed in the respective App). CommandString (named column 2 below): The string specified here is executed directly in the QM App per Execute. Any string specified in column 1 is processed accordingly as a string stack entry. (Examples are listed below) Variable (named column 3 below): With the message QM_ROW_EXECUTED, a stack entry that exists there can be sent back to the QM app using the ExecuteString and its processing in the target module. This stack entry is then saved in the variable specified in this column. Test access expressions: Access expressions can be specified starting from this column. The variables previously defined in the QM App serve as starting points for the access expressions. These access expressions are used to determine the values via the variables, which are then compared with the values stored in the Excel file in the lines. If these values do not match, an error message is displayed. syntax: Access printout Example: purchaseOrder supplier.uniqueID The test file must not contain any blank lines! Therefore, please make sure to always write REM; in the first column(#Flags) of the desired empty lines. Then it will work without the last line not being executed. A few hints for use and examples: Let's assume we want to create a requirement request and use it to create an order. This is how you proceed in the following rough steps: Create empty requirement coverage request Save requirements request via Save button Write part number in requisition item (which opens automatically when the header is saved) and send SELECT message to part number field Change quantity and save position via Save button Book header document Return variable of the requirement request item to our QM App Create order via usual message The following problems need to be solved: How do I send a variable back to the QM App? How do I send my requirement request variable from the QM app to another app via the test message, which only has one execute parameter? .and the solutions: SendMsg(QM_ROW_EXECUTED) in column 1, SendMsg(TEST_PURCHASE_REQUISITION_ITEM) in column 2 and the target variable in which we want to hold this position in the QM App, i.e. purchaseRequisitionItem in column 3. The QM app receives this response message and always stores it in the same temporary variable. Then the object is transferred from the temporary variable to the desired variable. The following execution sequence leads to the result, if, for example, the requirement coverage request item is to be drawn into the order as a predecessor: Column 1: Widget(EditWin, predecessors) SendMsg(PURCHASE_REQUISITION_ITEM_SELECTED, DIRECT) Column 2: purchaseRequisitionItem Swap SendMsg(TEST_PURCHASE_ORDER_ITEM) The swap places the variable purchaseRequisitionItem behind the string to be executed, resulting in the following statement: purchaseRequisitionItem "Widget(EditWin, predecessors) SendMsg(PURCHASE_REQUISITION_ITEM_SELECTED, DIRECT)" SendMsg(TEST_PURCHASE_REQUISITION_ITEM) When the test message is triggered, there are therefore 2 parameters on the stack: our requisition request position and on the TOP the string to be executed in the target app. At least one blank file and one fully functioning "example" test file is checked in at each branch. You can find these test files in the directory: \AppsWH\\\data\QS To use the BREAK; and the REM; instruction the following hionweis: This instruction always refers exactly to the beginning of the corresponding line: That means, just as you comment out the line with REM; you terminate with BREAK; also exactly BEFORE executing this line! The line containing the BREAK; is therefore no longer executed. Another tip: Window test messages If a procedure is to be executed via EXEC message, which contains access to widgets written without the leading EditWin, e.g. GetObject(, predecessors), a local test message can be created according to the following scheme: First part: test message (TEST_ORDER), second part window name: (EDIT_WIN) = TEST_ORDER_EDIT_WIN Another test message is defined in the app that receives the test message: Msg(TEST_ORDER_EDIT_WIN) Then ONLY in the action list of the window (here EditWin) this message is intercepted and only supplemented by an Execute: TEST_ORDER_EDIT_WIN: Execute Now you can call procedures directly from the window by Execute without having to add EditWin (the context) in all procedures, which would sometimes even be wrong (if the procedure is called from different windows!). However, the call of the message must then look a little different: Column 1: "SaveObject" SendMsg(TEST_ORDER_EDIT_WIN) Column 2: SendMsg(TEST_ORDER) The string to be executed in the window test message must be placed in inverted commas again, otherwise it would already be executed by the first execute (TEST_ORDER). With inverted commas, it is treated as a string and (without inverted commas) loaded onto the stack. Since the SendMsg(TEST_ORDER_EDIT_WIN) statement is not in the stack, this statement is executed and sends the previously loaded string as the next execution command to the window test message. Since not every app needs such a message, and this message should not trigger the app under any circumstances (otherwise there would probably be a lot of duplicate test executions, because customer derivations of these apps might still be created) and there should only be one defined interface to an app, this message should be added according to this scheme if necessary. Common errors that occur when creating a test file: LAZY_CREATOR: If an item of a document is held in a variable in the test file and this variable is used in a column to evaluate a slot or similar, the error message "Object not yet created" appears, although this item has already been linked to the header document. As the entire test process is carried out in one main transaction throughout the entire test suite, this LazyCreator is not converted into a persistent object. This must be done in the test file via the OBJECT Manager: position header document GetManager(OBJECT) Call(Instantiate) -> Variable. It is very important that the result of the instantiate is saved back into the variable of the position. Otherwise the old variable pointer still points to the LAZY_CREATOR. Example: orderItem order GetManager(OBJECT) Call(Instantiate) -> orderItem If orderItem is used in a column, this variable must be named differently as long as it still contains the LazyCreator. Because as long as it still points to the LazyCreator, attempts in columns such as orderItem::sales.pricePer will fail with an error message in the QM App. ALSO: Rename variable orderItem to orderItemTmp first and save it to the variable orderItem only after the Instantiate. Then also the column can be evaluated reasonably. Calling several test frameworks Call from the QM App: - Multiple selection of files - Select a folder to run all tests in it Call with a batch file: The exact path of the desired files and folders is stored in variables and assembled into a large string. Extract of a sample file: The spaces in the file names must be replaced with "***": SET STRING_1=%CX_QS_PATH%\Demo\Test file***Sample name1***-***Demo.xls (Test file Sample name1 - Demo.xls) SET STRING_2=%CX_QS_PATH%\Demo\Testdatei***Mustername2***-***Demo.xls SET STRING_3=%CX_OS_PATH%\Demo\validity The individual character strings are combined into one and are separated by "###": SET CX_ALL_TESTS=%STRING_1click="javascript:toggle_dynamic_var("###");" title="Click to edit dynamic variable: ###">No value assignedSTRING_2Novalue assignedSTRING_3% The call of the file which starts the tests with the variable CX_ALL_TESTS as the transfer parameter: call %CX_ROOTDIR%\projects\Start_Testframework.bat %CX_ALL_TESTS% General information: The selected files and folders are assembled into a string and used as transfer parameters for the calling batch file. In this file, the character string is saved as the environment variable "CX_TESTFRAMEWORKS". A new CyberEnterprise instance is opened, which reads the character string from the environment variable to call the first test. This test is removed from the string and when it is finished, the batch file is called again, with the new string as the transfer parameter. Thus the test frameworks run one after the other in a separate CyberEnterprise instance. If errors occur, error files are generated, but without the usual request to change to the test directory. Input window: In this window, you can set options for running the Test Frameworks, select Test Frameworks, and start them. Module name: testFrameworkEdit.app.